"""
reCamera C++ deployment deployer

Deploys C++ binary applications to reCamera devices via SSH.
Uses SysVinit for service management (/etc/init.d/S99xxx scripts).
"""

import asyncio
import logging
from typing import Callable, Optional, Dict, Any

from .ssh_binary_deployer import SSHBinaryDeployer
from ..models.device import DeviceConfig

logger = logging.getLogger(__name__)

# SysVinit service script template for reCamera
SYSVINIT_SCRIPT_TEMPLATE = '''#!/bin/sh
#
# {service_name} - {description}
#
# Generated by SenseCraft Solution Deployer
#

NAME="{service_name}"
DAEMON="{binary_path}"
DAEMON_ARGS="{daemon_args}"
PIDFILE="/var/run/$NAME.pid"
LOGFILE="/var/log/$NAME.log"

# Source function library if available
[ -r /etc/init.d/functions ] && . /etc/init.d/functions

start() {{
    echo -n "Starting $NAME: "
    if [ -f "$PIDFILE" ] && kill -0 $(cat "$PIDFILE") 2>/dev/null; then
        echo "already running"
        return 0
    fi

    # Start the daemon
    start-stop-daemon -S -b -m -p "$PIDFILE" -x "$DAEMON" -- $DAEMON_ARGS >> "$LOGFILE" 2>&1
    RETVAL=$?

    if [ $RETVAL -eq 0 ]; then
        echo "OK"
    else
        echo "FAIL"
    fi
    return $RETVAL
}}

stop() {{
    echo -n "Stopping $NAME: "
    if [ ! -f "$PIDFILE" ]; then
        echo "not running"
        return 0
    fi

    start-stop-daemon -K -p "$PIDFILE" -x "$DAEMON"
    RETVAL=$?
    rm -f "$PIDFILE"

    if [ $RETVAL -eq 0 ]; then
        echo "OK"
    else
        echo "FAIL"
    fi
    return $RETVAL
}}

restart() {{
    stop
    sleep 1
    start
}}

status() {{
    if [ -f "$PIDFILE" ] && kill -0 $(cat "$PIDFILE") 2>/dev/null; then
        echo "$NAME is running (pid $(cat $PIDFILE))"
        return 0
    else
        echo "$NAME is not running"
        return 1
    fi
}}

case "$1" in
    start)
        start
        ;;
    stop)
        stop
        ;;
    restart)
        restart
        ;;
    status)
        status
        ;;
    *)
        echo "Usage: $0 {{start|stop|restart|status}}"
        exit 1
        ;;
esac

exit $?
'''


class ReCameraCppDeployer(SSHBinaryDeployer):
    """Deploy C++ binaries to reCamera devices.

    This deployer extends the base SSHBinaryDeployer with reCamera-specific
    functionality:
    - Stops conflicting Node-RED flows before deployment
    - Creates SysVinit service scripts (/etc/init.d/S99xxx)
    - Manages services using SysVinit commands
    """

    async def _pre_deploy_hook(
        self,
        ssh_client,
        config: DeviceConfig,
        connection: Dict[str, Any],
        progress_callback: Optional[Callable] = None,
    ) -> bool:
        """Stop Node-RED flows and old C++ services before deployment."""

        await self._report_progress(
            progress_callback, "prepare", 30, "Stopping conflicting services..."
        )

        try:
            # Stop Node-RED sscma-node service if running
            await self._stop_nodered_service(ssh_client)

            # Stop any existing C++ services that might conflict
            await self._stop_old_cpp_services(ssh_client, config)

        except Exception as e:
            logger.warning(f"Failed to stop services (non-fatal): {e}")
            # Don't fail deployment if cleanup fails

        return True

    async def _stop_nodered_service(self, ssh_client) -> None:
        """Stop Node-RED related services on reCamera."""

        # Known Node-RED service patterns on reCamera
        nodered_services = [
            "S*sscma-node*",
            "S*nodered*",
            "S*node-red*",
        ]

        for pattern in nodered_services:
            cmd = f"ls /etc/init.d/{pattern} 2>/dev/null | while read f; do $f stop || true; done"
            await asyncio.to_thread(
                self._exec_with_timeout,
                ssh_client, cmd, 30
            )

        # Also try to stop via Node-RED Admin API (graceful shutdown)
        # This allows Node-RED to save its state
        try:
            import httpx

            # Get the reCamera IP from the SSH connection
            transport = ssh_client.get_transport()
            if transport:
                host = transport.getpeername()[0]
                async with httpx.AsyncClient(timeout=5.0) as client:
                    try:
                        # Node-RED admin API - stop flows
                        await client.post(
                            f"http://{host}:1880/flows/state",
                            json={"state": "stop"},
                            headers={"Content-Type": "application/json"},
                        )
                        logger.info("Node-RED flows stopped via Admin API")
                    except Exception:
                        pass  # API might not be available
        except ImportError:
            pass

        logger.info("Node-RED services stopped")

    async def _stop_old_cpp_services(self, ssh_client, config: DeviceConfig) -> None:
        """Stop any existing C++ services that might conflict."""

        # Get the service name from config
        binary_config = config.binary
        if binary_config and binary_config.service_name:
            service_name = binary_config.service_name
            # Try to stop the existing service
            cmd = f"ls /etc/init.d/S*{service_name}* 2>/dev/null | while read f; do $f stop || true; done"
            await asyncio.to_thread(
                self._exec_with_timeout,
                ssh_client, cmd, 30
            )

        # Also stop common C++ services
        common_services = ["sensecraft", "sscma", "recamera"]
        for service in common_services:
            cmd = f"ls /etc/init.d/S*{service}* 2>/dev/null | while read f; do $f stop || true; done"
            await asyncio.to_thread(
                self._exec_with_timeout,
                ssh_client, cmd, 30
            )

        # Kill any orphaned processes
        kill_cmds = [
            "pkill -f 'sensecraft' || true",
            "pkill -f 'sscma' || true",
        ]
        for cmd in kill_cmds:
            await asyncio.to_thread(
                self._exec_with_timeout,
                ssh_client, cmd, 10
            )

    async def _create_service_script(
        self,
        ssh_client,
        config: DeviceConfig,
        connection: Dict[str, Any],
        binary_path: str,
        progress_callback: Optional[Callable] = None,
    ) -> bool:
        """Create SysVinit service script for the C++ binary."""

        binary_config = config.binary
        if not binary_config:
            return True  # No service configuration needed

        # Determine service name and priority
        service_name = binary_config.service_name or config.id
        service_priority = binary_config.service_priority or 99
        description = binary_config.description or f"{service_name} service"
        daemon_args = binary_config.daemon_args or ""

        # Generate script content
        script_content = SYSVINIT_SCRIPT_TEMPLATE.format(
            service_name=service_name,
            description=description,
            binary_path=binary_path,
            daemon_args=daemon_args,
        )

        # Create script file path
        script_path = f"/etc/init.d/S{service_priority:02d}{service_name}"

        # Remove old service scripts with same name but different priority
        cleanup_cmd = f"rm -f /etc/init.d/S*{service_name}"
        await asyncio.to_thread(
            self._exec_with_timeout,
            ssh_client, cleanup_cmd, 10
        )

        # Write script to remote
        # Escape the content for shell
        escaped_content = script_content.replace("'", "'\\''")
        write_cmd = f"cat > {script_path} << 'EOFSCRIPT'\n{script_content}\nEOFSCRIPT"

        exit_code, _, stderr = await asyncio.to_thread(
            self._exec_with_timeout,
            ssh_client, write_cmd, 30
        )

        if exit_code != 0:
            logger.error(f"Failed to create service script: {stderr}")
            await self._report_progress(
                progress_callback, "configure", 0, f"Failed to create service script: {stderr}"
            )
            return False

        # Make script executable
        chmod_cmd = f"chmod +x {script_path}"
        exit_code, _, stderr = await asyncio.to_thread(
            self._exec_with_timeout,
            ssh_client, chmod_cmd, 10
        )

        if exit_code != 0:
            logger.error(f"Failed to make script executable: {stderr}")
            return False

        logger.info(f"Created service script: {script_path}")
        return True

    async def _start_service(
        self,
        ssh_client,
        config: DeviceConfig,
        connection: Dict[str, Any],
        progress_callback: Optional[Callable] = None,
    ) -> bool:
        """Start the C++ service using SysVinit."""

        binary_config = config.binary
        if not binary_config:
            return True

        service_name = binary_config.service_name or config.id
        service_priority = binary_config.service_priority or 99
        script_path = f"/etc/init.d/S{service_priority:02d}{service_name}"

        # Start the service
        start_cmd = f"{script_path} start"
        exit_code, stdout, stderr = await asyncio.to_thread(
            self._exec_with_timeout,
            ssh_client, start_cmd, 60
        )

        if exit_code != 0:
            logger.error(f"Failed to start service: {stderr}")
            return False

        logger.info(f"Service started: {stdout.strip()}")
        return True

    async def _verify_service(
        self,
        ssh_client,
        config: DeviceConfig,
        connection: Dict[str, Any],
        progress_callback: Optional[Callable] = None,
    ) -> bool:
        """Verify the C++ service is running."""

        binary_config = config.binary
        if not binary_config:
            return True

        service_name = binary_config.service_name or config.id
        service_priority = binary_config.service_priority or 99
        script_path = f"/etc/init.d/S{service_priority:02d}{service_name}"

        # Check service status
        status_cmd = f"{script_path} status"
        exit_code, stdout, stderr = await asyncio.to_thread(
            self._exec_with_timeout,
            ssh_client, status_cmd, 30
        )

        if exit_code == 0 and "running" in stdout.lower():
            logger.info(f"Service verified: {stdout.strip()}")
            return True

        # Service might not have a status command, try to check process
        binary_path = binary_config.install_path or f"/usr/local/bin/{service_name}"
        check_cmd = f"pgrep -f '{binary_path}'"
        exit_code, stdout, _ = await asyncio.to_thread(
            self._exec_with_timeout,
            ssh_client, check_cmd, 10
        )

        if exit_code == 0 and stdout.strip():
            logger.info(f"Process running with PID: {stdout.strip()}")
            return True

        logger.warning("Service verification failed")
        return False
